library( pander )       # formatting
library( knitr )        # formatting
library( DT )           # table printing
library( httr )         # web requests
library( xmltools )     # xml utilities
library( xml2 )         # xml utilities
library( XML )          # xml utilities
library( data.tree )    # network visualization
library( networkD3 )    # network visualization
library( igraph )       # network visualization
source( "R/rdb-functions-v2.R")
source( "R/utils.R")
#######
#######  DATA USED IN THE REPORT:
#######  UPDATE TO MATCH TABLE
#######
# IF THE TABLE IS IN THE 990/990EZ MAIN FORM
index <-
tinyindex %>%
dplyr::filter( FormType %in% c("990","990EZ") )
# IF THE TABLE IS IN A SCHEDULE:
# index <- read_csv( "schedule-samples/SCHEDA.csv" )
###  ALL SCHEDULES
###
#   "SCHEDA", "SCHEDB", "SCHEDC",
#   "SCHEDD", "SCHEDE", "SCHEDF",
#   "SCHEDG", "SCHEDH", "SCHEDI",
#   "SCHEDJ", "SCHEDK", "SCHEDL",
#   "SCHEDM", "SCHEDN", "SCHEDO",
#   "SCHEDR"
head( index )
column.order <-
c("variable_name", "xpath", "description", "location_code_xsd",
"location_code_family", "location_code", "form", "form_type",
"form_part", "form_line_number", "variable_scope", "data_type_xsd",
"data_type_simple", "rdb_relationship", "rdb_table", "required",
"versions", "latest_version", "duplicated", "current_version",
"production_rule", "validated")
concordance <-
concordance[ , column.order ]  %>%
arrange( variable_name )
concordance %>%
filter( rdb_table == table.name )
t.xpaths <-
concordance %>%
filter( rdb_table == table.name ) %>%
select( xpath ) %>%
unique() %>%
arrange( xpath ) %>%
mutate( id=row_number() )
t.xpaths %>%
kable( align="l" )
xpaths <- as.character( t.xpaths$xpath )
el <- create_edgelist_v1( xpaths )
nd <- FromDataFrameNetwork( network=el )
print( nd )
SetGraphStyle( nd, rankdir = "LR")
SetEdgeStyle( nd, arrowhead = "vee", color = "grey20", penwidth = 2 )
SetNodeStyle( nd,
style = "filled,rounded",
shape = "box",
fillcolor = "LightBlue",
fontname = "helvetica",
fontcolor="black",
tooltip = GetDefaultTooltip )
# SetNodeStyle(acme$IT, fillcolor = "LightBlue", penwidth = "5px")
plot( nd )
# old version
find_group_names( table.name )
# new version
find_table_headers( table.name )
# manual
if( ! is.null(table.headers) )
{table.headers}
# create new folder
dir.create( folder.name )
setwd( folder.name )
# create sample
set.seed( 1234 )
sample.index <- sample_n( index, sample.size )
write.csv( index, "sample-index.csv", row.names=F )
sample.urls <- sample.index$URL
# erase existing log files
file.create("XPATH-LOG.txt")
file.create("FAIL-LOG.txt")
start.build.time <- Sys.time()    # --------------------
results.list <- list()
xpath.list <- list()
for( i in 1:length( sample.urls ) )
{
url <- sample.urls[i]
results.list[[i]] <-
build_rdb_table_v2( url,
table.name,
table.headers=table.headers )
xpath.list[[i]]   <-
get_table_xpaths( url,
table.name,
table.headers=table.headers )
if( i %% 100 == 0 ){ print(i) }
}
end.build.time <- Sys.time()      # --------------------
df <- dplyr::bind_rows( results.list )
fail.log <- readLines( "FAIL-LOG.txt" )
all.xpaths <- xpath.list %>% unlist() %>% unique() %>% sort()
cat( all.xpaths, sep="\n", file="XPATH-LOG.txt" )
# print( paste0(  "TABLE:   ", table.name ) )
print( paste0( "NUMBER OF RETURNS PROCESSED:   ", length(sample.urls) ) )
print( paste0( "TOTAL NUMBER OF TABLE ROWS:   ", nrow(df) ) )
# NUMBER OF RETURNS PROCESSED:   **`r length(sample.urls)`**
# TOTAL NUMBER OF TABLE ROWS:   **`r nrow(df)`**
print( end.build.time - start.build.time )
print( difftime( start.build.time, end.build.time, units="hours") )
write.csv( df, paste0( folder.name, "/", table.name, ".csv" ), row.names=F )
head(df)
names(df)
c.table <- dplyr::filter( concordance, rdb_table == table.name )
xpath.concordance <- c.table$xpath
setdiff( all.xpaths, xpath.concordance )
these <- setdiff( all.xpaths, xpath.concordance )
cat( these, sep="\n", file=paste0( folder.name, "/MISSING-XPATHS.txt" ) )
if( length(fail.log) > 0 )
{
sapply( fail.log, get_message ) %>%
table() %>%
pander()
} else {
print("ALL URLs ARE VALID")
}
# KEEP ROOT NOTES Return & ReturnData
el <- create_edgelist_v1( all.xpaths )
el.demo <-
structure(list(V1 = c("Return", "ReturnData", "IRS990", "Form990PartVIISectionAGrp",
"Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp",
"Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp"
), V2 = c("ReturnData", "IRS990", "Form990PartVIISectionAGrp",
"PersonNm", "TitleTxt", "AverageHoursPerWeekRt", "IndividualTrusteeOrDirectorInd",
"OfficerInd", "ReportableCompFromOrgAmt", "ReportableCompFromRltdOrgAmt"
)), row.names = c(NA, 10L), class = "data.frame")
el.demo %>% pander()
# library( data.tree )
nd <- FromDataFrameNetwork( network=el )
# SET TABLE PARAMETERS FOR THE REPORT;
# ALSO SEE DATA STEP BELOW
table.name <- "F9-P07-T01-COMPENSATION-HCE-EZ"
### Use two levels of the path
### to ensure the table header
### is unique (headers can be
### reused in schedules).
###
### Use a double-slash at the
### start of the table header:
###
### "//Form990PartVIII/ProgramServiceRevenue"
# table.headers <- NULL
table.headers <-
c("//IRS990EZ/CompensationHighestPaidEmplGrp",
"//IRS990EZ/CompensationOfHighestPaidEmpl")
folder.name <- paste0( "TABLE-", table.name )
sample.size <- 500
knitr::opts_chunk$set( echo=TRUE, message=F, warning=F, fig.width=10 )
library( irs990efile )  # functions for parsing efile XMLs
library( dplyr )        # data wrangling
library( purrr )        # data wrangling
library( pander )       # formatting
library( knitr )        # formatting
library( DT )           # table printing
library( httr )         # web requests
library( xmltools )     # xml utilities
library( xml2 )         # xml utilities
library( XML )          # xml utilities
library( data.tree )    # network visualization
library( networkD3 )    # network visualization
library( igraph )       # network visualization
source( "R/rdb-functions-v2.R")
source( "R/utils.R")
#######
#######  DATA USED IN THE REPORT:
#######  UPDATE TO MATCH TABLE
#######
# IF THE TABLE IS IN THE 990/990EZ MAIN FORM
index <-
tinyindex %>%
dplyr::filter( FormType %in% c("990","990EZ") )
# IF THE TABLE IS IN A SCHEDULE:
# index <- read_csv( "schedule-samples/SCHEDA.csv" )
###  ALL SCHEDULES
###
#   "SCHEDA", "SCHEDB", "SCHEDC",
#   "SCHEDD", "SCHEDE", "SCHEDF",
#   "SCHEDG", "SCHEDH", "SCHEDI",
#   "SCHEDJ", "SCHEDK", "SCHEDL",
#   "SCHEDM", "SCHEDN", "SCHEDO",
#   "SCHEDR"
head( index )
column.order <-
c("variable_name", "xpath", "description", "location_code_xsd",
"location_code_family", "location_code", "form", "form_type",
"form_part", "form_line_number", "variable_scope", "data_type_xsd",
"data_type_simple", "rdb_relationship", "rdb_table", "required",
"versions", "latest_version", "duplicated", "current_version",
"production_rule", "validated")
concordance <-
concordance[ , column.order ]  %>%
arrange( variable_name )
concordance %>%
filter( rdb_table == table.name )
t.xpaths <-
concordance %>%
filter( rdb_table == table.name ) %>%
select( xpath ) %>%
unique() %>%
arrange( xpath ) %>%
mutate( id=row_number() )
t.xpaths %>%
kable( align="l" )
xpaths <- as.character( t.xpaths$xpath )
el <- create_edgelist_v1( xpaths )
nd <- FromDataFrameNetwork( network=el )
print( nd )
SetGraphStyle( nd, rankdir = "LR")
SetEdgeStyle( nd, arrowhead = "vee", color = "grey20", penwidth = 2 )
SetNodeStyle( nd,
style = "filled,rounded",
shape = "box",
fillcolor = "LightBlue",
fontname = "helvetica",
fontcolor="black",
tooltip = GetDefaultTooltip )
# SetNodeStyle(acme$IT, fillcolor = "LightBlue", penwidth = "5px")
plot( nd )
# old version
find_group_names( table.name )
# new version
find_table_headers( table.name )
# manual
if( ! is.null(table.headers) )
{table.headers}
# create new folder
dir.create( folder.name )
setwd( folder.name )
# create sample
set.seed( 1234 )
sample.index <- sample_n( index, sample.size )
write.csv( index, "sample-index.csv", row.names=F )
sample.urls <- sample.index$URL
# erase existing log files
file.create("XPATH-LOG.txt")
file.create("FAIL-LOG.txt")
start.build.time <- Sys.time()    # --------------------
results.list <- list()
xpath.list <- list()
for( i in 1:length( sample.urls ) )
{
url <- sample.urls[i]
results.list[[i]] <-
build_rdb_table_v2( url,
table.name,
table.headers=table.headers )
xpath.list[[i]]   <-
get_table_xpaths( url,
table.name,
table.headers=table.headers )
if( i %% 100 == 0 ){ print(i) }
}
end.build.time <- Sys.time()      # --------------------
df <- dplyr::bind_rows( results.list )
fail.log <- readLines( "FAIL-LOG.txt" )
all.xpaths <- xpath.list %>% unlist() %>% unique() %>% sort()
cat( all.xpaths, sep="\n", file="XPATH-LOG.txt" )
# print( paste0(  "TABLE:   ", table.name ) )
print( paste0( "NUMBER OF RETURNS PROCESSED:   ", length(sample.urls) ) )
print( paste0( "TOTAL NUMBER OF TABLE ROWS:   ", nrow(df) ) )
# NUMBER OF RETURNS PROCESSED:   **`r length(sample.urls)`**
# TOTAL NUMBER OF TABLE ROWS:   **`r nrow(df)`**
print( end.build.time - start.build.time )
print( difftime( start.build.time, end.build.time, units="hours") )
write.csv( df, paste0( folder.name, "/", table.name, ".csv" ), row.names=F )
head(df)
names(df)
c.table <- dplyr::filter( concordance, rdb_table == table.name )
xpath.concordance <- c.table$xpath
setdiff( all.xpaths, xpath.concordance )
these <- setdiff( all.xpaths, xpath.concordance )
cat( these, sep="\n", file=paste0( folder.name, "/MISSING-XPATHS.txt" ) )
if( length(fail.log) > 0 )
{
sapply( fail.log, get_message ) %>%
table() %>%
pander()
} else {
print("ALL URLs ARE VALID")
}
# KEEP ROOT NOTES Return & ReturnData
el <- create_edgelist_v1( all.xpaths )
el.demo <-
structure(list(V1 = c("Return", "ReturnData", "IRS990", "Form990PartVIISectionAGrp",
"Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp",
"Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp"
), V2 = c("ReturnData", "IRS990", "Form990PartVIISectionAGrp",
"PersonNm", "TitleTxt", "AverageHoursPerWeekRt", "IndividualTrusteeOrDirectorInd",
"OfficerInd", "ReportableCompFromOrgAmt", "ReportableCompFromRltdOrgAmt"
)), row.names = c(NA, 10L), class = "data.frame")
el.demo %>% pander()
# library( data.tree )
nd <- FromDataFrameNetwork( network=el )
# SET TABLE PARAMETERS FOR THE REPORT;
# ALSO SEE DATA STEP BELOW
table.name <- "F9-P07-T01-COMPENSATION-HCE-EZ"
### Use two levels of the path
### to ensure the table header
### is unique (headers can be
### reused in schedules).
###
### Use a double-slash at the
### start of the table header:
###
### "//Form990PartVIII/ProgramServiceRevenue"
# table.headers <- NULL
table.headers <-
c("//IRS990EZ/CompensationHighestPaidEmplGrp",
"//IRS990EZ/CompensationOfHighestPaidEmpl")
folder.name <- paste0( "TABLE-", table.name )
sample.size <- 1000
knitr::opts_chunk$set( echo=TRUE, message=F, warning=F, fig.width=10 )
library( irs990efile )  # functions for parsing efile XMLs
library( dplyr )        # data wrangling
library( purrr )        # data wrangling
library( pander )       # formatting
library( knitr )        # formatting
library( DT )           # table printing
library( httr )         # web requests
library( xmltools )     # xml utilities
library( xml2 )         # xml utilities
library( XML )          # xml utilities
library( data.tree )    # network visualization
library( networkD3 )    # network visualization
library( igraph )       # network visualization
source( "R/rdb-functions-v2.R")
source( "R/utils.R")
#######
#######  DATA USED IN THE REPORT:
#######  UPDATE TO MATCH TABLE
#######
# IF THE TABLE IS IN THE 990/990EZ MAIN FORM
index <-
tinyindex %>%
dplyr::filter( FormType %in% c("990","990EZ") )
# IF THE TABLE IS IN A SCHEDULE:
# index <- read_csv( "schedule-samples/SCHEDA.csv" )
###  ALL SCHEDULES
###
#   "SCHEDA", "SCHEDB", "SCHEDC",
#   "SCHEDD", "SCHEDE", "SCHEDF",
#   "SCHEDG", "SCHEDH", "SCHEDI",
#   "SCHEDJ", "SCHEDK", "SCHEDL",
#   "SCHEDM", "SCHEDN", "SCHEDO",
#   "SCHEDR"
head( index )
column.order <-
c("variable_name", "xpath", "description", "location_code_xsd",
"location_code_family", "location_code", "form", "form_type",
"form_part", "form_line_number", "variable_scope", "data_type_xsd",
"data_type_simple", "rdb_relationship", "rdb_table", "required",
"versions", "latest_version", "duplicated", "current_version",
"production_rule", "validated")
concordance <-
concordance[ , column.order ]  %>%
arrange( variable_name )
concordance %>%
filter( rdb_table == table.name )
t.xpaths <-
concordance %>%
filter( rdb_table == table.name ) %>%
select( xpath ) %>%
unique() %>%
arrange( xpath ) %>%
mutate( id=row_number() )
t.xpaths %>%
kable( align="l" )
xpaths <- as.character( t.xpaths$xpath )
el <- create_edgelist_v1( xpaths )
nd <- FromDataFrameNetwork( network=el )
print( nd )
SetGraphStyle( nd, rankdir = "LR")
SetEdgeStyle( nd, arrowhead = "vee", color = "grey20", penwidth = 2 )
SetNodeStyle( nd,
style = "filled,rounded",
shape = "box",
fillcolor = "LightBlue",
fontname = "helvetica",
fontcolor="black",
tooltip = GetDefaultTooltip )
# SetNodeStyle(acme$IT, fillcolor = "LightBlue", penwidth = "5px")
plot( nd )
# old version
find_group_names( table.name )
# new version
find_table_headers( table.name )
# manual
if( ! is.null(table.headers) )
{table.headers}
# create new folder
dir.create( folder.name )
setwd( folder.name )
# create sample
set.seed( 1234 )
sample.index <- sample_n( index, sample.size )
write.csv( index, "sample-index.csv", row.names=F )
sample.urls <- sample.index$URL
# erase existing log files
file.create("XPATH-LOG.txt")
file.create("FAIL-LOG.txt")
start.build.time <- Sys.time()    # --------------------
results.list <- list()
xpath.list <- list()
for( i in 1:length( sample.urls ) )
{
url <- sample.urls[i]
results.list[[i]] <-
build_rdb_table_v2( url,
table.name,
table.headers=table.headers )
xpath.list[[i]]   <-
get_table_xpaths( url,
table.name,
table.headers=table.headers )
if( i %% 100 == 0 ){ print(i) }
}
end.build.time <- Sys.time()      # --------------------
df <- dplyr::bind_rows( results.list )
fail.log <- readLines( "FAIL-LOG.txt" )
all.xpaths <- xpath.list %>% unlist() %>% unique() %>% sort()
cat( all.xpaths, sep="\n", file="XPATH-LOG.txt" )
# print( paste0(  "TABLE:   ", table.name ) )
print( paste0( "NUMBER OF RETURNS PROCESSED:   ", length(sample.urls) ) )
print( paste0( "TOTAL NUMBER OF TABLE ROWS:   ", nrow(df) ) )
# NUMBER OF RETURNS PROCESSED:   **`r length(sample.urls)`**
# TOTAL NUMBER OF TABLE ROWS:   **`r nrow(df)`**
print( end.build.time - start.build.time )
print( difftime( start.build.time, end.build.time, units="hours") )
write.csv( df, paste0( folder.name, "/", table.name, ".csv" ), row.names=F )
head(df)
names(df)
c.table <- dplyr::filter( concordance, rdb_table == table.name )
xpath.concordance <- c.table$xpath
setdiff( all.xpaths, xpath.concordance )
these <- setdiff( all.xpaths, xpath.concordance )
cat( these, sep="\n", file=paste0( folder.name, "/MISSING-XPATHS.txt" ) )
if( length(fail.log) > 0 )
{
sapply( fail.log, get_message ) %>%
table() %>%
pander()
} else {
print("ALL URLs ARE VALID")
}
# KEEP ROOT NOTES Return & ReturnData
el <- create_edgelist_v1( all.xpaths )
el.demo <-
structure(list(V1 = c("Return", "ReturnData", "IRS990", "Form990PartVIISectionAGrp",
"Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp",
"Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp", "Form990PartVIISectionAGrp"
), V2 = c("ReturnData", "IRS990", "Form990PartVIISectionAGrp",
"PersonNm", "TitleTxt", "AverageHoursPerWeekRt", "IndividualTrusteeOrDirectorInd",
"OfficerInd", "ReportableCompFromOrgAmt", "ReportableCompFromRltdOrgAmt"
)), row.names = c(NA, 10L), class = "data.frame")
el.demo %>% pander()
# library( data.tree )
nd <- FromDataFrameNetwork( network=el )
print( nd )
SetGraphStyle( nd, rankdir = "LR")
SetEdgeStyle( nd, arrowhead = "vee", color = "grey20", penwidth = 2 )
SetNodeStyle( nd,
style = "filled,rounded",
shape = "box",
fillcolor = "LightBlue",
fontname = "helvetica",
fontcolor="black",
tooltip = GetDefaultTooltip )
# SetNodeStyle(acme$IT, fillcolor = "LightBlue", penwidth = "5px")
plot( nd )
# library( networkD3 )
# net <- ToDataFrameNetwork( nd, "name" )
# simpleNetwork( net, fontSize = 12 )
simpleNetwork( el, fontSize = 12 )
#plot with networkD3
radnet <- ToListExplicit( nd, unname = TRUE )
radialNetwork( radnet, fontSize = 12 )
t.xpaths <-
concordance %>%
filter( rdb_table == table.name ) %>%
select( xpath ) %>%
unique() %>%
arrange( xpath ) %>%
mutate( id=row_number() )
t.xpaths %>%
kable( align="l" )
if( is.null(table.headers) )
{ find_table_headers( table.name ) } else
table.headers
if( is.null(table.headers) )
{ table.headers <- find_table_headers( table.name ) }
demo.url <- "https://nccs-efile.s3.us-east-1.amazonaws.com/xml/201913079349300206_public.xml"
doc <- xml2::read_xml( demo.url )
xml2::xml_ns_strip( doc )
df.demo <- get_table_v2( doc, table.name, table.headers )
df.demo
get_var_map( table.name=table.name )
v.map <- get_var_map( table.name=table.name )
if( ! is.null(df.demo) )
{re_name( df.demo, v.map ) %>% as.data.frame()}
